(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["form-schema"] = factory();
	else
		root["form-schema"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.FormFieldError = exports.FormError = exports.ANY_KEY = exports.Form = undefined;
	exports.form = form;
	exports.field = field;
	exports.validate = validate;

	var _FormError = __webpack_require__(1);

	var _FormField = __webpack_require__(2);

	var _FormFieldError = __webpack_require__(3);

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _typeof(obj) { return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	//
	// NOTE: Couldn't put Form class into its own file src/Form.js because doing so
	// would result in a Webpack build error "a dependency to an entry point is not allowed".
	// See https://github.com/webpack/webpack/issues/300 for more details.
	// It's quite a peculiar error. Probably the cause of the error is the circular
	// dependency between src/Form.js and src/index.js. Until the library is re-designed
	// to avoid such circular dependency, Form class will reside in this file.
	//

	var Form = exports.Form = (function () {
	  function Form(schema) {
	    _classCallCheck(this, Form);

	    this._schema = schema;
	  }

	  _createClass(Form, [{
	    key: 'getSchema',
	    value: function getSchema() {
	      return this._schema;
	    }
	  }, {
	    key: 'required',
	    value: function required() {
	      this._isRequired = true;
	      return this;
	    }
	  }, {
	    key: 'validate',
	    value: function validate(data) {
	      if (typeof data === 'undefined' || data === null && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
	        return this._isRequired ? {
	          isValid: false,
	          errors: ['The form is required.']
	        } : {
	          isValid: true,
	          errors: []
	        };
	      }
	      /* eslint-disable no-use-before-define */

	      for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        rest[_key - 1] = arguments[_key];
	      }

	      var result = validateHelper.apply(undefined, [data, this._schema].concat(rest));
	      /* eslint-enable no-use-before-define */
	      return result;
	    }
	  }]);

	  return Form;
	})();

	var ANY_KEY = exports.ANY_KEY = Symbol('any key');

	function form() {
	  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	    args[_key2] = arguments[_key2];
	  }

	  return new (Function.prototype.bind.apply(Form, [null].concat(args)))();
	}

	function field() {
	  for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	    args[_key3] = arguments[_key3];
	  }

	  return new (Function.prototype.bind.apply(_FormField.FormField, [null].concat(args)))();
	}

	exports.FormError = _FormError.FormError;
	exports.FormFieldError = _FormFieldError.FormFieldError;

	function validateHelper(data, _schema) {
	  var ancestors = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];
	  var keyPath = arguments.length <= 3 || arguments[3] === undefined ? [] : arguments[3];

	  var dataType = typeof data === 'undefined' ? 'undefined' : _typeof(data);
	  dataType = dataType === 'object' && Array.isArray(data) ? 'array' : dataType;

	  var schema = _schema;
	  if (typeof schema === 'function') {
	    schema = _schema();
	  }

	  if (schema instanceof Form) {
	    var result = schema.validate(data, ancestors, keyPath);
	    result.errorFactory = _FormError.formError;
	    return result;
	  } else if (schema instanceof _FormField.FormField) {
	    // NOTE: You cannot assume the data at this point is a primitive.
	    var result = schema.validate(data, ancestors, keyPath);
	    result.errorFactory = _FormFieldError.formFieldError;
	    return result;
	  } else if (Array.isArray(schema)) {
	    // array
	    if (Array.isArray(data)) {
	      // iterate array and validate element
	      var resultArr = data.map(function (x, index) {
	        return validateHelper(x, schema[0], [data].concat(_toConsumableArray(ancestors)), [index].concat(_toConsumableArray(keyPath)));
	      });
	      var isValid = resultArr.every(function (x) {
	        return x.isValid;
	      });
	      return {
	        isValid: isValid,
	        result: resultArr
	      };
	    }
	    return {
	      isValid: false,
	      errors: ['Expected array but got ' + dataType + '.'],
	      errorFactory: _FormFieldError.formFieldError
	    };
	  } else if ((typeof schema === 'undefined' ? 'undefined' : _typeof(schema)) === 'object') {
	    // object
	    if (dataType === 'object') {
	      var _ret = (function () {
	        var resultObj = null;
	        // If the special key, ANY_KEY, is present, use its value as schema to
	        // validate all the values in the data.
	        if (schema[ANY_KEY]) {
	          resultObj = Object.keys(data).reduce(function (acc, key) {
	            acc[key] = validateHelper(data[key], schema[ANY_KEY], [data].concat(_toConsumableArray(ancestors)), [key].concat(_toConsumableArray(keyPath)));
	            return acc;
	          }, {});
	        } else {
	          // iterate key and validate value
	          resultObj = Object.keys(schema).reduce(function (acc, key) {
	            acc[key] = validateHelper(data[key], schema[key], [data].concat(_toConsumableArray(ancestors)), [key].concat(_toConsumableArray(keyPath)));
	            return acc;
	          }, {});
	        }
	        var isValid = Object.keys(resultObj).every(function (key) {
	          return resultObj[key].isValid;
	        });
	        return {
	          v: {
	            isValid: isValid,
	            result: resultObj
	          }
	        };
	      })();

	      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	    }
	    return {
	      isValid: false,
	      errors: ['Expected object but got ' + dataType + '.'],
	      errorFactory: _FormFieldError.formFieldError
	    };
	  }
	  throw new Error('validateHelper(): Not supposed to reach here.');
	}

	function compactResult(result) {
	  if (result.isValid) {
	    return null;
	  } else if (result.result) {
	    var _ret2 = (function () {
	      var subResult = result.result;
	      if (Array.isArray(subResult)) {
	        return {
	          v: subResult.map(compactResult)
	        };
	      } else if ((typeof subResult === 'undefined' ? 'undefined' : _typeof(subResult)) === 'object') {
	        return {
	          v: Object.keys(subResult).reduce(function (acc, key) {
	            acc[key] = compactResult(subResult[key]);
	            return acc;
	          }, {})
	        };
	      }
	      throw new Error('compactResult(): Not supposed to reach here.');
	    })();

	    if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
	  }
	  return result.errorFactory(result.errors, result.data);
	}

	function validate(data, schema) {
	  var result = validateHelper(data, schema);
	  var compactedResult = compactResult(result);
	  return {
	    isValid: result.isValid,
	    errors: compactedResult
	  };
	}

/***/ },
/* 1 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.formError = formError;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var FormError = exports.FormError = (function (_Error) {
	  _inherits(FormError, _Error);

	  function FormError(reasons, data) {
	    _classCallCheck(this, FormError);

	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(FormError).call(this));

	    _this.name = 'FormError';
	    _this.reasons = reasons;
	    _this.data = data;
	    Error.captureStackTrace(_this, FormError);
	    return _this;
	  }

	  return FormError;
	})(Error);

	function formError() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  return new (Function.prototype.bind.apply(FormError, [null].concat(args)))();
	}

/***/ },
/* 2 */
/***/ function(module, exports) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _typeof(obj) { return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var FormField = exports.FormField = (function () {
	  function FormField(attrs) {
	    _classCallCheck(this, FormField);

	    this._attrs = attrs;
	    this._validators = [];
	  }

	  _createClass(FormField, [{
	    key: 'validators',
	    value: function validators() {
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      this._validators = args;
	      return this;
	    }
	  }, {
	    key: 'required',
	    value: function required() {
	      this._isRequired = true;
	      return this;
	    }
	  }, {
	    key: 'isRequired',
	    value: function isRequired() {
	      return this._isRequired;
	    }
	  }, {
	    key: 'getAttributes',
	    value: function getAttributes() {
	      return this._attrs;
	    }
	  }, {
	    key: 'validate',
	    value: function validate(value) {
	      for (var _len2 = arguments.length, rest = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	        rest[_key2 - 1] = arguments[_key2];
	      }

	      if (typeof value === 'undefined' || value === null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
	        return this._isRequired ? {
	          isValid: false,
	          errors: ['The field is required.']
	        } : {
	          isValid: true,
	          errors: []
	        };
	      }
	      var result = this._validators.reduce(function (_ref, validator) {
	        var isValid = _ref.isValid;
	        var errors = _ref.errors;

	        var _validator = validator.apply(undefined, [value].concat(rest));

	        var valid = _validator.isValid;
	        var error = _validator.error;

	        if (!valid) {
	          errors.push(error);
	        }
	        return {
	          isValid: isValid && valid,
	          errors: errors
	        };
	      }, {
	        isValid: true,
	        errors: []
	      });
	      return _extends({}, result, {
	        data: value
	      });
	    }
	  }]);

	  return FormField;
	})();

/***/ },
/* 3 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.formFieldError = formFieldError;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var FormFieldError = exports.FormFieldError = (function (_Error) {
	  _inherits(FormFieldError, _Error);

	  function FormFieldError(reasons, data) {
	    _classCallCheck(this, FormFieldError);

	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(FormFieldError).call(this));

	    _this.name = 'FormFieldError';
	    _this.reasons = reasons;
	    _this.data = data;
	    Error.captureStackTrace(_this, FormFieldError);
	    return _this;
	  }

	  return FormFieldError;
	})(Error);

	function formFieldError() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  return new (Function.prototype.bind.apply(FormFieldError, [null].concat(args)))();
	}

/***/ }
/******/ ])
});
;