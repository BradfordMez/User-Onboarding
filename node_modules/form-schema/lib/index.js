'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FormFieldError = exports.FormError = exports.ANY_KEY = exports.Form = undefined;
exports.form = form;
exports.field = field;
exports.validate = validate;

var _FormError = require('./FormError');

var _FormField = require('./FormField');

var _FormFieldError = require('./FormFieldError');

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _typeof(obj) { return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//
// NOTE: Couldn't put Form class into its own file src/Form.js because doing so
// would result in a Webpack build error "a dependency to an entry point is not allowed".
// See https://github.com/webpack/webpack/issues/300 for more details.
// It's quite a peculiar error. Probably the cause of the error is the circular
// dependency between src/Form.js and src/index.js. Until the library is re-designed
// to avoid such circular dependency, Form class will reside in this file.
//

var Form = exports.Form = (function () {
  function Form(schema) {
    _classCallCheck(this, Form);

    this._schema = schema;
  }

  _createClass(Form, [{
    key: 'getSchema',
    value: function getSchema() {
      return this._schema;
    }
  }, {
    key: 'required',
    value: function required() {
      this._isRequired = true;
      return this;
    }
  }, {
    key: 'validate',
    value: function validate(data) {
      if (typeof data === 'undefined' || data === null && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
        return this._isRequired ? {
          isValid: false,
          errors: ['The form is required.']
        } : {
          isValid: true,
          errors: []
        };
      }
      /* eslint-disable no-use-before-define */

      for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        rest[_key - 1] = arguments[_key];
      }

      var result = validateHelper.apply(undefined, [data, this._schema].concat(rest));
      /* eslint-enable no-use-before-define */
      return result;
    }
  }]);

  return Form;
})();

var ANY_KEY = exports.ANY_KEY = Symbol('any key');

function form() {
  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return new (Function.prototype.bind.apply(Form, [null].concat(args)))();
}

function field() {
  for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }

  return new (Function.prototype.bind.apply(_FormField.FormField, [null].concat(args)))();
}

exports.FormError = _FormError.FormError;
exports.FormFieldError = _FormFieldError.FormFieldError;

function validateHelper(data, _schema) {
  var ancestors = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];
  var keyPath = arguments.length <= 3 || arguments[3] === undefined ? [] : arguments[3];

  var dataType = typeof data === 'undefined' ? 'undefined' : _typeof(data);
  dataType = dataType === 'object' && Array.isArray(data) ? 'array' : dataType;

  var schema = _schema;
  if (typeof schema === 'function') {
    schema = _schema();
  }

  if (schema instanceof Form) {
    var result = schema.validate(data, ancestors, keyPath);
    result.errorFactory = _FormError.formError;
    return result;
  } else if (schema instanceof _FormField.FormField) {
    // NOTE: You cannot assume the data at this point is a primitive.
    var result = schema.validate(data, ancestors, keyPath);
    result.errorFactory = _FormFieldError.formFieldError;
    return result;
  } else if (Array.isArray(schema)) {
    // array
    if (Array.isArray(data)) {
      // iterate array and validate element
      var resultArr = data.map(function (x, index) {
        return validateHelper(x, schema[0], [data].concat(_toConsumableArray(ancestors)), [index].concat(_toConsumableArray(keyPath)));
      });
      var isValid = resultArr.every(function (x) {
        return x.isValid;
      });
      return {
        isValid: isValid,
        result: resultArr
      };
    }
    return {
      isValid: false,
      errors: ['Expected array but got ' + dataType + '.'],
      errorFactory: _FormFieldError.formFieldError
    };
  } else if ((typeof schema === 'undefined' ? 'undefined' : _typeof(schema)) === 'object') {
    // object
    if (dataType === 'object') {
      var _ret = (function () {
        var resultObj = null;
        // If the special key, ANY_KEY, is present, use its value as schema to
        // validate all the values in the data.
        if (schema[ANY_KEY]) {
          resultObj = Object.keys(data).reduce(function (acc, key) {
            acc[key] = validateHelper(data[key], schema[ANY_KEY], [data].concat(_toConsumableArray(ancestors)), [key].concat(_toConsumableArray(keyPath)));
            return acc;
          }, {});
        } else {
          // iterate key and validate value
          resultObj = Object.keys(schema).reduce(function (acc, key) {
            acc[key] = validateHelper(data[key], schema[key], [data].concat(_toConsumableArray(ancestors)), [key].concat(_toConsumableArray(keyPath)));
            return acc;
          }, {});
        }
        var isValid = Object.keys(resultObj).every(function (key) {
          return resultObj[key].isValid;
        });
        return {
          v: {
            isValid: isValid,
            result: resultObj
          }
        };
      })();

      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
    }
    return {
      isValid: false,
      errors: ['Expected object but got ' + dataType + '.'],
      errorFactory: _FormFieldError.formFieldError
    };
  }
  throw new Error('validateHelper(): Not supposed to reach here.');
}

function compactResult(result) {
  if (result.isValid) {
    return null;
  } else if (result.result) {
    var _ret2 = (function () {
      var subResult = result.result;
      if (Array.isArray(subResult)) {
        return {
          v: subResult.map(compactResult)
        };
      } else if ((typeof subResult === 'undefined' ? 'undefined' : _typeof(subResult)) === 'object') {
        return {
          v: Object.keys(subResult).reduce(function (acc, key) {
            acc[key] = compactResult(subResult[key]);
            return acc;
          }, {})
        };
      }
      throw new Error('compactResult(): Not supposed to reach here.');
    })();

    if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
  }
  return result.errorFactory(result.errors, result.data);
}

function validate(data, schema) {
  var result = validateHelper(data, schema);
  var compactedResult = compactResult(result);
  return {
    isValid: result.isValid,
    errors: compactedResult
  };
}